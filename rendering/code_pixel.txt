static int load_img(t_data *data, t_texture *tex, char *path)
{
        t_img img;
        int x;
        int y;

        y = -1;
        img.ptr_img = mlx_xpm_file_to_image(data->mlx, path, &img.width, &img.height);
        if (!img.ptr_img)
                return (ft_error("error: malloc failed"));
        img.data = (int *)mlx_get_data_addr(img.ptr_img, &img.bpp, &img.line_length, &img.endian);
        tex->pixies = (int *)malloc(img.width * img.height * sizeof(int));
        if (!tex->pixies)
                return (mlx_destroy_image(data->mlx, img.ptr_img), ft_error("error: malloc failed"));
        while (++y < img.height)
        {
                x = -1;
                while (++x < img.width)
                        tex->pixies[y * img.width + x] = img.data[y * img.width + x];
        }
        mlx_destroy_image(data->mlx, img.ptr_img);
        return (EXIT_SUCCESS);
}

static int get_texture(t_data *data, t_texture *tex)
{
        int fd;

        fd = open(tex->path, O_RDONLY);
        if (fd == -1)
                return (ft_error("error: open failed"));
        if (load_img(data, tex, tex->path))
                return (EXIT_FAILURE);
        return (EXIT_SUCCESS);
}

int init_textures(t_data *data)
{
        if (get_texture(data, &data->info.texture_N)
                || get_texture(data, &data->info.texture_S)
                || get_texture(data, &data->info.texture_E)
                || get_texture(data, &data->info.texture_W))
                return (EXIT_FAILURE);
        return (EXIT_SUCCESS);
}


++++++++++++++++


static void put_pixel(t_img *frame, int x, int y, unsigned int color)
{
        if (x >= 0 && y >= 0 && x <= WIN_WIDTH && y <= WIN_HEIGHT
                && ((y * WIN_WIDTH + x) <= (WIN_WIDTH * WIN_HEIGHT - 1)))
                frame->data[y * WIN_WIDTH + x] = color;
        else
                printf("(%d %d) %x\n", x, y, color); // <<TAKE out
}

static unsigned int get_color(t_data *data, t_ray *ray, int x, int y)
{
        if (ray->side && ray->cast[Y] < 0)
                return (data->info.texture_S.pixies[y * TEX_WIDTH + x]);
        else if (ray->side && ray->cast[Y] > 0)
                return (data->info.texture_N.pixies[y * TEX_WIDTH + x]);
        else if (!ray->side && ray->cast[X] > 0)
                return (data->info.texture_W.pixies[y * TEX_WIDTH + x]);
        else if (!ray->side && ray->cast[X] < 0)
                return (data->info.texture_E.pixies[y * TEX_WIDTH + x]);
        return (0x000000);
}

static void calibrate_texture(t_data *data, t_wall *wall, t_ray *ray)
{
        if (ray->side)
                wall->x = data->player.pos[X] + ray->perp_dist * ray->cast[X];
        else
                wall->x = data->player.pos[Y] + ray->perp_dist * ray->cast[Y];
        wall->x -= floor(wall->x);
        wall->tex_X = (int) (wall->x * (double) TEX_WIDTH);
        if (!ray->side && ray->cast[X] > 0) 
                wall->tex_X = TEX_WIDTH - wall->tex_X - 1;
        if (ray->side && ray->cast[Y] < 0)
                wall->tex_X = TEX_WIDTH - wall->tex_X - 1;
        wall->step = 1.0 * TEX_HEIGHT / wall->h;
        wall->pos = (wall->start - WIN_HEIGHT / 2 + wall->h / 2) * wall->step;        
}

void render_column(t_data *data, t_img *frame, t_ray *ray, int x)
{
        t_wall wall;
        int y;

        wall.h = (int) (WIN_HEIGHT / ray->perp_dist); //hunt down perp_dist
        wall.start = -wall.h / 2 + WIN_HEIGHT / 2;
        if (wall.start < 0)
                wall.start = 0;
        wall.end = wall.h / 2 + WIN_HEIGHT / 2;
        if (wall.end >= WIN_HEIGHT)
                wall.end = WIN_HEIGHT - 1;
        calibrate_texture(data, &wall, ray);
        y = wall.start - 1;
        while (++y <= wall.end)
        {
                wall.tex_Y = (int) wall.pos & (TEX_HEIGHT - 1);
                wall.pos += wall.step;
                put_pixel(frame, x, y, get_color(data, ray, wall.tex_X, wall.tex_Y));
        }
        y = -1;
// if (!x)
// printf("wall %d ray->perp_disti %f start %d\n", wall.h, ray->perp_dist, wall.start);
        while (++y < wall.start)
        {
                put_pixel(frame, x, y, data->info.color_C);
        }
        y = wall.end;
        while (++y < WIN_HEIGHT)
                put_pixel(frame, x, y, data->info.color_F);
// if (!x)
// printf("!rendering\n");
}
 




 +++++++



 bool	set_values(const char *buffer)
{
	t_xpm_ex	*values;
	char		**temp;
	char	**temp0;

	values = malloc(sizeof(t_xpm_ex));
	if (!values)
		return (true);
	temp = ft_split(buffer, ' ');
	if (!temp)
		return (true);
	temp0 = ft_split(buffer, '"');
	if (!temp0)
		return (true);
	if (!temp0[0] || !temp[1] || !temp[2] || !temp[3])
		return (couble_free(temp), couble_free(temp0), true);
	values->width = ft_atoi(temp0[0]);
	values->height = ft_atoi(temp[1]);
	values->num_colors = ft_atoi(temp[2]);
	values->chars_per_pixel = ft_atoi(temp[3]);
	if (values->width != TILE_SIZE || values->height != TILE_SIZE ||
		values->num_colors <= 0 || values->chars_per_pixel != 1)
		return (couble_free(temp), couble_free(temp0), true);
	couble_free(temp);
	couble_free(temp0);	
	return (false);
}

bool	lokaka(const char *buffer)
{
	int	i;

	if (!buffer)
		return (true);
	i = -1;
	while (++i, buffer[i])
	{
		if (buffer[i] != '"' && buffer[i] != ' ' && !ft_isdigit(buffer[i]) &&
			buffer[i] != ',' && buffer[i] != '\n')
			return (true);
	}
	return (false);
}

bool	get_values(int fd0)
{
	char	*buffer;

	buffer = get_next_line(fd0);
	if (!buffer)
		return (true);
	while (buffer)
	{
		if (!lokaka(buffer))
		{
			if (set_values(buffer))
				return (true);
			
		}
		free(buffer);
		buffer = get_next_line(fd0);
	}
	return (false);
}

bool	get_colors(int fd)
{
	
}

bool	set_xpm(int	fd0)
{
	if (get_values(fd0))
		return (error("invalid xpm"), true);
	if (get_colors(fd0))
		return(error("Invalid xpm"), true);
	return (false);
}

bool	init_xpm(t_textures *texture)
{
	int	fd0;
//	int	fd1;
//	int	fd2;
	(void) texture;
	fd0 = open("img/dollar.xpm", O_RDONLY);
	//printf("%s\n", texture->north);
	if (fd0 < 0)
		return (error("Error: with the file"), true);
	if (set_xpm(fd0))
		return (true) ;
//	fd1 = open("ttexture->south", O_RDONLY);
//	if (fd1 < 0)
//		return (error("Error: with the file"), close(fd0), true);
//	fd2 = open("texture->south", O_RDONLY);
///	if (fd2 < 0)
//		return (error("Error: with the file"), close(fd0), close(fd1),true);
	return(false);
}

